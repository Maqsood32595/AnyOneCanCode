import * as vscode from 'vscode';
import * as fs from 'fs';
import * as path from 'path';
import { exec } from 'child_process';
import { CheckpointPanel, handleCheckpoint, handleReset } from './checkpointPanel';
import { AIPanel } from './aiPanel';

export function activate(context: vscode.ExtensionContext) {
	console.log('Congratulations, your extension "anyone-can-code" is now active!');

	// Store protected code patterns at different levels
	const projectProtectedPatterns: string[] = [];
	const testProtectedPatterns: string[] = [];
	
	// Preloaded prompts for different levels
	const projectPreloadedPrompts = [
		"Have you tested this code thoroughly at project level?",
		"Does this follow the project's overall architecture?",
		"Have you considered project-wide edge cases?",
		"Will this affect other modules in the project?",
		"Have you updated project documentation?",
		"Does this break any project-wide functionality?",
		"Have you considered project performance implications?",
		"Is this consistent with project coding standards?",
		"Have you coordinated with other team members?",
		"Does this need project-level error handling?"
	];

	const testPreloadedPrompts = [
		"Have you covered all test cases for this functionality?",
		"Are your tests independent and not order-dependent?",
		"Have you tested both success and failure scenarios?",
		"Are your tests readable and maintainable?",
		"Have you removed any test-specific debug code?",
		"Does this test follow the testing framework best practices?",
		"Have you considered edge cases in your tests?",
		"Are your test names descriptive and meaningful?",
		"Have you verified test coverage is adequate?",
		"Does this test need additional assertions?"
	];

	// Hello World command
	let helloWorld = vscode.commands.registerCommand('anyone-can-code.helloWorld', () => {
		vscode.window.showInformationMessage('Hello World from Anyone Can Code!');
	});

	// Coding Tip command
	let codingTip = vscode.commands.registerCommand('anyone-can-code.codingTip', () => {
		const tips = [
			"Start with small, working programs and gradually add features",
			"Don't be afraid to make mistakes - they're learning opportunities",
			"Practice regularly, even if it's just 15 minutes a day",
			"Read other people's code to learn different approaches",
			"Use comments to explain your thought process",
			"Break complex problems into smaller, manageable parts",
			"Test your code frequently as you develop",
			"Learn to use debugging tools - they're your best friends",
			"Don't copy-paste code without understanding what it does",
			"Consistent naming conventions make your code more readable"
		];
		
		const randomTip = tips[Math.floor(Math.random() * tips.length)];
		vscode.window.showInformationMessage(`Coding Tip: ${randomTip}`);
	});

	// Create Tests Folder command
	let createTests = vscode.commands.registerCommand('anyone-can-code.createTests', async () => {
		if (!vscode.workspace.workspaceFolders) {
			vscode.window.showErrorMessage('Please open a workspace first!');
			return;
		}

		const workspacePath = vscode.workspace.workspaceFolders[0].uri.fsPath;
		const testsPath = path.join(workspacePath, 'tests');
		
		try {
			// Create tests directory
			if (!fs.existsSync(testsPath)) {
				fs.mkdirSync(testsPath);
			}

			// Create test subdirectories
			const testTypes = ['unit', 'integration', 'e2e', 'performance'];
			for (const testType of testTypes) {
				const typePath = path.join(testsPath, testType);
				if (!fs.existsSync(typePath)) {
					fs.mkdirSync(typePath);
				}

				// Create sample test files
				const sampleTest = `// ${testType} tests
// Generated by Anyone Can Code extension

describe('Sample ${testType} test', () => {
  it('should pass', () => {
    expect(true).toBe(true);
  });
  
  it('should demonstrate basic testing', () => {
    const result = 2 + 2;
    expect(result).toBe(4);
  });
});`;

				fs.writeFileSync(path.join(typePath, `sample.${testType}.test.js`), sampleTest);
			}

			// Create README for tests
			const readmeContent = `# Tests Directory

This directory contains automated tests for your project.

## Test Types:
- **unit**: Tests individual units/functions in isolation
- **integration**: Tests how different units work together
- **e2e**: End-to-end tests that simulate user behavior
- **performance**: Tests for performance and scalability

## Running Tests:
\`\`\`bash
# Install testing framework (if not already installed)
npm install --save-dev jest

# Run all tests
npm test

# Run specific test types
npm test -- unit
npm test -- integration
\`\`\`

Generated by Anyone Can Code extension`;

			fs.writeFileSync(path.join(testsPath, 'README.md'), readmeContent);

			vscode.window.showInformationMessage('Tests folder structure created successfully!');
			
			// Open the tests folder in explorer
			vscode.commands.executeCommand('revealFileInOS', vscode.Uri.file(testsPath));

		} catch (error) {
			vscode.window.showErrorMessage(`Error creating tests folder: ${error}`);
		}
	});

	// Show Project Level Prompt command
	let showProjectPrompt = vscode.commands.registerCommand('anyone-can-code.showProjectPrompt', async () => {
		const randomPrompt = projectPreloadedPrompts[Math.floor(Math.random() * projectPreloadedPrompts.length)];
		const result = await vscode.window.showInformationMessage(
			`Project Review: ${randomPrompt}`,
			'Yes',
			'No',
			'Add to Project Protected'
		);

		if (result === 'Add to Project Protected') {
			projectProtectedPatterns.push(randomPrompt);
			vscode.window.showInformationMessage('Added to project protected patterns!');
		}
	});

	// Show Test Level Prompt command
	let showTestPrompt = vscode.commands.registerCommand('anyone-can-code.showTestPrompt', async () => {
		const randomPrompt = testPreloadedPrompts[Math.floor(Math.random() * testPreloadedPrompts.length)];
		const result = await vscode.window.showInformationMessage(
			`Test Review: ${randomPrompt}`,
			'Yes',
			'No',
			'Add to Test Protected'
		);

		if (result === 'Add to Test Protected') {
			testProtectedPatterns.push(randomPrompt);
			vscode.window.showInformationMessage('Added to test protected patterns!');
		}
	});

	// Add Project Protected Pattern command
	let addProjectProtectedPattern = vscode.commands.registerCommand('anyone-can-code.addProjectProtectedPattern', async () => {
		const pattern = await vscode.window.showInputBox({
			prompt: 'Enter project-level code pattern to protect',
			placeHolder: 'projectConfig or databaseConnection'
		});

		if (pattern) {
			projectProtectedPatterns.push(pattern);
			vscode.window.showInformationMessage(`Project pattern "${pattern}" protected!`);
		}
	});

	// Add Test Protected Pattern command
	let addTestProtectedPattern = vscode.commands.registerCommand('anyone-can-code.addTestProtectedPattern', async () => {
		const pattern = await vscode.window.showInputBox({
			prompt: 'Enter test-level code pattern to protect',
			placeHolder: 'testSetup or mockData'
		});

		if (pattern) {
			testProtectedPatterns.push(pattern);
			vscode.window.showInformationMessage(`Test pattern "${pattern}" protected!`);
		}
	});

	// Check Protected Code command (both levels)
	let checkProtectedCode = vscode.commands.registerCommand('anyone-can-code.checkProtectedCode', () => {
		const editor = vscode.window.activeTextEditor;
		if (!editor) {
			vscode.window.showErrorMessage('No active editor found!');
			return;
		}

		const document = editor.document;
		const text = document.getText();
		const fileName = document.fileName;
		const isTestFile = fileName.includes('test') || fileName.includes('spec');

		let foundProjectPatterns: string[] = [];
		let foundTestPatterns: string[] = [];

		// Check project patterns
		for (const pattern of projectProtectedPatterns) {
			if (text.includes(pattern)) {
				foundProjectPatterns.push(pattern);
			}
		}

		// Check test patterns (only in test files)
		if (isTestFile) {
			for (const pattern of testProtectedPatterns) {
				if (text.includes(pattern)) {
					foundTestPatterns.push(pattern);
				}
			}
		}

		if (foundProjectPatterns.length > 0 || foundTestPatterns.length > 0) {
			let message = '';
			if (foundProjectPatterns.length > 0) {
				message += `Project patterns: ${foundProjectPatterns.join(', ')}. `;
			}
			if (foundTestPatterns.length > 0) {
				message += `Test patterns: ${foundTestPatterns.join(', ')}. `;
			}
			message += 'Handle with care!';
			
			vscode.window.showWarningMessage(message, 'Show Details');
		} else {
			vscode.window.showInformationMessage('No protected patterns found in current file.');
		}
	});

	// View Protected Patterns command
	let viewProtectedPatterns = vscode.commands.registerCommand('anyone-can-code.viewProtectedPatterns', () => {
		let message = 'Protected Patterns:\n\n';
		
		if (projectProtectedPatterns.length > 0) {
			message += 'Project Level:\n';
			projectProtectedPatterns.forEach((pattern, index) => {
				message += `${index + 1}. ${pattern}\n`;
			});
			message += '\n';
		}

		if (testProtectedPatterns.length > 0) {
			message += 'Test Level:\n';
			testProtectedPatterns.forEach((pattern, index) => {
				message += `${index + 1}. ${pattern}\n`;
			});
		}

		if (projectProtectedPatterns.length === 0 && testProtectedPatterns.length === 0) {
			message = 'No protected patterns defined yet.';
		}

		vscode.window.showInformationMessage(message);
	});

	// Show Checkpoint Panel command
	let showCheckpointPanel = vscode.commands.registerCommand('anyone-can-code.showCheckpointPanel', () => {
		CheckpointPanel.createOrShow(context.extensionUri);
	});

	// Create Checkpoint command
	let createCheckpoint = vscode.commands.registerCommand('anyone-can-code.createCheckpoint', async () => {
		try {
			const timestamp = await handleCheckpoint(context);
			vscode.window.showInformationMessage('Checkpoint created.');
			
			// Update panel if it's open
			if (CheckpointPanel.currentPanel) {
				CheckpointPanel.currentPanel.updateStatus(`Last checkpoint: ${timestamp}`);
			}
		} catch (error) {
			vscode.window.showErrorMessage(`Checkpoint failed: ${error instanceof Error ? error.message : String(error)}`);
		}
	});

	// Reset to Checkpoint command
	let resetToCheckpoint = vscode.commands.registerCommand('anyone-can-code.resetToCheckpoint', async () => {
		try {
			await handleReset();
			vscode.window.showInformationMessage('Project reset to checkpoint.');
		} catch (error) {
			vscode.window.showErrorMessage(`Reset failed: ${error instanceof Error ? error.message : String(error)}`);
		}
	});

	// AI Chat command
	let aiChat = vscode.commands.registerCommand('anyone-can-code.aiChat', () => {
		AIPanel.createOrShow(context.extensionUri);
	});

	context.subscriptions.push(
		helloWorld, 
		codingTip, 
		createTests, 
		showProjectPrompt, 
		showTestPrompt,
		addProjectProtectedPattern,
		addTestProtectedPattern,
		checkProtectedCode,
		viewProtectedPatterns,
		showCheckpointPanel,
		createCheckpoint,
		resetToCheckpoint,
		aiChat
	);
}

export function deactivate() {}
